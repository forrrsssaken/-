*Выражение* задает порядок выполнения действий над данными и состоит из *операндов* (констант, переменных, обращений к функциям), *круглых скобок* и *знаков операций*

Выражения бывают: 
	*арифметические*    a+b * sin(cos(X));
	*сравнение ( отношения)*   a+c>=0;
	*логические*  a+b<0&& x == y|| true.

*Операции* делятся на *унарные* и *бинарные*

**Операции в C/C++** 
![[Pasted image 20250908120026.png]]

**Операции C/C++**
![[Pasted image 20250908120614.png]]

**Операции C/C++**
![[Pasted image 20250908121018.png]]

**Операции C/C++**
![[Pasted image 20250908121508.png]]

 Рассмотрим пример программы на языке C++, включающий стандартные арифметические операции.

==Ввод и замена данных. Программа на языке C++==

	#include <iostream>  
	using namespace std;
	void main(void) {
	int a=5, b=12, i , i1;
	float c=20.4, d=2.2, rez;
	rez=c*d;
	i=(a+2)*b;
	i1=b%a
	cout<<"c*d="<<rez;
	cout<<"\n(a+2)*b="<<i;
	cout<<"\nb%a="<<i1;
	}

Результатом работы программы будет вывод на экран:

	c*d=44.88
	(a+2)*b=84
	b%a=2


- ***Операция определения остатка (%).*** Результатом данной операции является остаток от целочисленного деления, то есть это минимальное число, которое необходимо вычесть из делимого для того, чтобы в качестве частного получилось целое. 

	12%5=2
	a%b== 0
==//выражение, проверяющее что a кратно b==
- ***Арифметическое И (&).*** Оба операнда переводятся в двоичную систему, затем к ним применяется операция логического поразрядного умножения по следующим правилам: 

	1 & 1 = 1
	1 & 0 = 0
	0 & 1 = 0
	0 & 0 = 0

Например: если A=13 и B=23, то A&B=13&23=5

A=0000000000001101
B=0000000000010111
A&B=0000000000000101

- *Арифметические **ИЛИ*** (|). Здесь также оба операнда переводятся в двоичную систему, после чего происходит логическое поразрядное сложение по следующим правилам:
	1 |1 = 1
	1 | 0 = 1
	0 | 1 = 1
	0 | 0 = 0

Например: если А=13 и В=23, то A|B=13|23=31

A = 0000000000001101
B = 0000000000010111
A | B =0000000000011111

- *Арифметическое исключающее **ИЛИ*** (^). Оба операнда переводятся в двоичную систему, после чего выполняется логическая поразрядная операция ^ по следующим правилам:

	1 ^ 1 = 0
	1 ^ 0 = 1
	0 ^ 1 = 1
	0 ^ 0 = 0

- *Арифметическое отрицание (~)*. Эта операция выполняется над одним операндом. Применение операции ~ вызывает побитную инверсию двоичного представления числа.

Например: если А=13

	А = 0000000000001101
	
	~А = 111111111110010


- *Сдвиг влево* (M<<L).  Двоичное представление числа M сдвигается влево на L позиций (Операция M<<L эквивалентна умножению числа M на 2 в степени L). 

Например: M=17, L=3

	17<<3 ->   10001
	
	<- сдвиг на 3 влево
	
	10001000 -> 136 ( перевод в десятичную систему)

Результат: 17<<3 = 136

- *Сдвиг вправо* (M>>L). В этом случае двоичное представление числа M сдвигается вправо на L позиций, что эквивалентно целочисленному делению числа M на 2 в степени L.

Например: 25>>1 = 12

		11001 -> 11001 -> 1100 -> 12 (в 10 с.с.)


**Логические операции**

*Приоритетность* выполнения логических операций и операций отношения: 

-  !
- > , < , <= , >= , == , !=
- &&
- ||

Например:  :B<D || A>C && A < D

т.е. данное выражение будет восприниматься как:

	(B<D) || ((A>C) && (A<D))


- **Условная операция** 

Для организации разветвлений в простейшем случае можно использовать ***условную операцию ? : .*** Эта операция имеет три операнда и в общем виде может быть представлена
![[Pasted image 20250908205206.png]]
Если условие истинно (не равно 0), то результатом будет выражение 1, в противном случае выражение 2.

Обычно его используют в тех случаях, когда в зависимости от некоторых условий надо присвоить переменной одно из двух значений.

==// Определение наименьшего числа.==

	#include <iostream>
	void main(void)
	{
	int A, B, MIN;
	cout<< "Введите первое число:" ;
	cin>>A;
	cout<<"\nВведите второе число:" ;
	cin>>B;
	MIN=(A<B)  ? A : B;
	cout <<"\nНаименьшее число =  " << MIN <<"\n";
	}

- **Преобразование типов и операций приведения**

При построении выражений язык С/СН допускает использование переменных и констант разных типов. В этом случае при обработке выражения компилятор осуществляет ***автоматическое преобразование типов*** к одному, руководствуясь следующими *основными правилами*:
1) Операнды разных типов приводятся к более старшему типу. Этот процесс называется "повышением" типа. Старшинство типа операнда определяется исходя из размера памяти, отводимого под хранение данных. Перечислим типы данных в порядке убывания их старшинства: ***long double, double, float, unsigned long, long, unsigned int, int, short int, char. .*** 
2) При выполнении операции присваивания тип результата вычисления выражения в правой части приводится к типу переменной слева от знака присваивания. Это может привести как к "повышению". к "понижению" типа.

Преобразование, связанное с "повышением" типа, обычно происходит успешно и дает корректный результат. Преобразование же старших типов в младшие может привести к изменению результирующего значения вследствие выхода за возможный диапазон значений младшего типа.

Например: 

	 /* Автоматическое преобразование типов
	 Программа на языке C */
	 #include <stdio.h>
	 void main(void)
	 {
	 float a=2.2,  b=5.5, d;
	 int c=1;
	 d= (a+2)*(c+b);
	 printf ("d=%f\n", d);
	 }

В данном случае при выполнении расчета целочисленные данные были автоматически преобразованы в вещественный тип, и затем вещественное значение было присвоено переменной d уже без преобразования.

Например:

	/*Деление целых чисел. Программа на языке C */
	#include <stdio.h>
	void main(void)
	{
	int a=1, b=2;
	float c;
	c=a/b;
	printf ("c=%f\n", c);
	}
Результат:
c=0.000000


***Операции приведения типов***

Язык C/C++ позволяет программисту самостоятельно управлять преобразованием типов данных. Для этого служит ***операция приведения типа:*** **(тип) выражения**

Здесь *тип* может быть любым допустимым типом C/C++ и результатом операции является значение выражения, преобразованное к данному типу.

Например: 

	(int)A - преобразует А к целому типу;
	
	(unsigned long)B - преобразует В к длинному целому без знака.


В C++ введена дополнительная возможность *приведения типов* вида: **тип (выражения)** 

Данное преобразование имеет ***ограничение***: *тип должен иметь простое (выражаемое одним словом) обозначение,* то есть нельзя писать.

	 unsigned int (C) - для преобразования C к целому типу без знака

Например: 

	int (A) - преобразует А к целому типу;
	long (B) - преобразует B к длинному целому типу.

Изменим предыдущую программу

	/* Деление целых чисел. Вариант 2. Программа на языке С */
	#include <stdio.h>
	void main(void)
	{
	int a=1, b=2;
	float c;
	c=(float)a/b;
	printf ("c=%f\n", c);
	}
Результатом данной программы будет вывод на экран:
c=0.500000

***Стандартные математические функции в C/C++*** определены в заголовочных файлах <math.h> **или** < math >
![[Pasted image 20250910095542.png]]

**Стандартные математические функции**
![[Pasted image 20250910095749.png]]
![[Pasted image 20250910100106.png]]

	#define Pi 3.145292....;
	
	const double Pi=3.145292...;
	
	double Pi=M_Pi; //Файл math.h


	cos|a+1|^(b+1)-e^-(sin(a)+sqrt(b)) + 2.7*10^-17
	
	cos(pow(abs(a+1), b+1)) - exp(abs(sin(a)+sqrt(b))) + 2.7e-17


	pow(1/TAN/(cos(75*M_Pi/180)+sin(M_Pi/3))/exp(ln(sin(sqrt fabs(a))))),2)+ exp (-4*a*c/(2+a))

***Приоритет и ассоциативность операций языка C/C++ влияют на порядок группирования операндов и вычисления выражения.  В таблице приведены операции языка C/C++ в порядке убывания приоритета.***
![[Pasted image 20250910105535.png]]
