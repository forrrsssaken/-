### Понятие процесса 
﻿
﻿- С процессом связывается определённый программный код, который для этих целей оформляется в виде **исполняемого модуля.**
﻿﻿- Процесс рассматривается операционной системой как **заявка на потребление** всех видов ресурсов, кроме одного - процессорного времени, распределяемого между другими единицами работы - потоками.
﻿﻿- Для того чтобы процессы не могли вмешаться в распределение ресурсов, а также не могли повредить коды и данные друг друга, важнейшей задачей ОС является **изоляция одного процесса от другого.** Для этого ОС обеспечивает каждый процесс отдельным виртуальным адресным пространством, ни один процесс не может получить прямого доступа к командам и данным другого процесса.

### Состояние процесса. Примитивные схемы

Для мультипрограммных вычислительных систем псевдопараллельная обработка нескольких процессов достигается с помощью **переключения процессора с одного процесса на другой**. Пока один процесс выполняется, остальные ждут своей очереди.![[Pasted image 20250925132900.png]]
Простейшая схема состояния процесса - деление на
2 состояния: **исполняется** и **не исполняется.**
![[Pasted image 20250925132945.png]]
Приостановка процесса происходит по двум причинам: для его дальнейшей работы потребовалось какое-либо **событие** (например, завершение операции ввода-вывода) или **истек временной интервал**, отведенный операционной системой для работы данного процесса. Образуется новое состояние - **ожидание.**

### Состояния процесса. Общая модель
Для появления в вычислительной системе процесс должен пройти через состояние **рождение**. При завершении деятельности он попадает в состояние **закончил исполнение.**
![[Pasted image 20250925133455.png]]
Более адекватная схема состояний процесса включает **5 состояний**. Причём выйти из состояния исполнения процесс может по трем причинам:
- ОС прекращает его деятельность;
- он не может продолжать работу, ожидая некоторое событие;
- в результате возникновения прерывания в ВС (например, от таймера по истечении предусмотренного бремени выполнения) его возвращают в состояние готовность.
В конкретных Ос состояния процесса могут быть еще более детализированы. Так, например, модель состояний процессов для ОС Windows NT содержит 7 различных состояний, а для Ос Unix - 9.

### Операции над процессами
Процесс не может перейти, из одного состояния в другое самостоятельно.
Изменением состояния процессов занимается ОС, совершая операции над ними.

Удобно объединить их в **три пары**:
﻿﻿- **создание** процесса - **завершение** процесса;
﻿﻿- **приостановка** процесса (перевод из состояния исполнение в готовность) - **запуск** процесса (перевод из состояния готовность в состояние исполнение);
﻿﻿- **блокирование** процесса (перевод из состояния исполнение в ожидание) - **разблокирование** процесса (перевод из состояния ожидание в готовность).
В дальнейшем, в нашей модели появится еще одна операция, не имеющая парной: **изменение приоритета** процесса.
Операции создания и завершения процесса являются **одноразовыми**, остальные - могут применяться к процессам **многократно**.

### Process Control Block и контекст процесса
Для того, чтобы Ос могла выполнять операции над процессорами, каждый процесс представляется в ней некоторой **структурой данных** (назовём её **PCB**). Эта структура содержит информацию, специфическую для данного процесса:
- **состояние**, в котором находится процесс;
- **программный счетчик** процесса или, другими словами, адрес команды, которая должна быть выполнена для него следующей;
- содержимое **регистров** процессора;
- **данные,** необходимые для планирования использования процессора и управления памятью;
- **учетные данные** (идентификационный номер процесса, какой пользователь инициировал его работу, общее время использования процессора данным процессом и т. д.);
﻿﻿- сведения об **устройствах ввода-вывода**, связанных с процессом (например, какие устройства закреплены за процессом, таблицу открытых файлов).
Любая операция, производимая операционной системой над процессом, вызывает определенные изменения в РСВ.

### Три контекста процесса
﻿﻿- **Регистровый** - отвечает за содержимое всех регистров процессора (включая значение программного счетчика).
﻿- ﻿**Пользовательский** -это код и данные, находящиеся в адресном пространстве текущего процесса.
﻿﻿- **Системный** -все остальные составляющие РСВ (блока управления процессом).

Между изменениями состояний процессов, т.е. операциями над ними, содержимое
РСВ остается **постоянным**. Совокупность з контекстов процесса: регистрового, системного и пользовательского для краткости принято называть просто контекстом.
В любой момент времени процесс полностью характеризуется своим **контекстом**.

### Одноразовые операции: создание

Инициатором рождения нового процесса после старта ОС может выступить либо процесс **пользователя**, совершивший специальный системный вызов, либо сама **ОС.**
![[Pasted image 20250925135720.png]]
Процесс, инициировавший создание нового, принято называть **процессом-родителем** (parent process), a вновь созданный процесс - **процессом-ребенком** (child process). Процессы-дети могут в свою очередь порождать новых детей и т. д, образуя, внутри системы набор генеалогических деревьев процессов.
При рождении процесса система заводит новый РСВ с состоянием процесса рождение и начинает его заполнять. Новый процесс получает собственный **уникальный идентификационный номер (PID)**. Поскольку для хранения PID процесса в ОС отводится ограниченное количество битов, количество одновременно присутствующих в ней процессов ограничено.
Для выполнения своих функций процесс-ребенок требует ресурсов: памяти, файлов, устройств ввода-вывода и т. д. Существует **два подхода** к их выделению: взять из **родительских ресурсов** или получить **непосредственно от ОС**. Unix поддерживает порождение только 1 способом, Windows - оба варианта.

### Одноразовые операции: завершение
После того, как процесс завершил свою работу, ОС переводит его в состояние закончил исполнение и освобождает все **ассоциированные с ним ресурсы**, делая соответствующие записи в блоке управления процессом.
﻿﻿- РСВ не уничтожается, в остается в системе некоторое время, тк. процесс-родитель может запросить ОС о причине «завершения» порожденного им процесса и/или статистическую информацию о нём.
﻿﻿- После завершения процесса его PID может быть повторно использован для другого процесса.
﻿﻿- В ряде ОС гибель процесса-родителя приводит к завершению дочерних процессов В других ОС (Unix) процессы-дети продолжают свое существование и после окончания работы процесса-родителя.

BOC Unix (Linux) процессы, находящиеся в состоянии «закончил исполнение», принято называть **процессами-зомби**, а запускающиеся в фоновом режиме и не имеющие прямого отношения к работе пользователя называют **демонами**.

### Многоразовые операции

Многоразовые операции, не приводят к изменению количества процессов и не обязаны быть связанными с выделением или освобождением ресурсов.
﻿﻿
﻿﻿- **Запуск процесса**. Из числа процессов, находящихся в состоянии готовность, ОС выбирает один для последующего исполнения, обеспечивает наличие в оперативной памяти необходимой информации. Состояние процесса изменяется на исполнение, восстанавливаются значения регистров и управление
﻿﻿- **Приостановка процесса**. Работа процесса в состоянии исполнение приостанавливается в результате какого-либо прерывания. Процессор автоматически сохраняет счетчик команд и, возможно, один или несколько регистров в стеке исполняемого процесса, а затем передает управление по специальному
﻿﻿- **Блокирование процесса.** Процесс блокируется, когда он не может продолжать работу, не дождавшись возникновения какого-либо события в ВС. Для этого он обращается к ОС с помощью определенного системного вызова и переходит в состояние ожидание.
﻿- ﻿**Разблокирование процесса**. После возникновения в системе какого-либо события ОС нужно точно определить тип события. Затем найти процесс в состоянии ожидания для данного события, и если он есть, перевести его в состояние *готовность*, выполнив необходимые связенные с событием действия, (инициализация операции ввода-вывода для очередного ожидающего процесса и т. п).

### Переключение контекста
Деятельность **мультипрограммной ОС** состоит из цепочек операций, выполняемых над процессами, и сопровождается переключением процессора с одного процесса на другой.

Выполнение операции **разблокирования** процесса 2 показано на рисунке слева.
Использование термина «код пользователя» не ограничивает общности рисунка только пользовательскими процессами.![[Pasted image 20250925142335.png]]

Для корректного переключения процессора с одного процесса на другой необходимо сохранить контекст исполнявшегося процесса и восстановить контекст процесса, на который будет переключен процессор.

Процедура сохранения/восстановления работоспособности процессов называется **переключением контекста**.

### Уровни планирования

- **Долгосрочное** - отвечает за порождение новых процессов, определяя степень (коэффициент) мультипрограммирования, т. е. число процессов, одновременно находящихся в системе. Между появлением новых процессов могут проходить десятки минут.
﻿﻿- **Краткосрочное** - планирование использования процессора. Проводится при обращении процесса к устройствам ввода-вывода, по завершении определенного интервала времени и т.д. Осуществляется не реже одного раза в 100 миллисекунд
﻿﻿- **Среднесрочное**- отвечает за перекачку (swapping) того или иного процесса на диск и обратно. Создано для разгрузки ОП и повышения производительности ВС. 
По времени занимает среднее значение по сравнению с предыдущими уровнями.

### Критерии планирования
﻿﻿- Справедливость - гарантировать каждому процессу определенную часть времени процессора.
﻿﻿- Эффективность - постараться занять процессор на все 100% рабочего времени, не позволяему простаивать. В реальных вычислительных системах загрузка процессора колеблется от 40 до gо%.
﻿﻿- Сокращение полного времени выполнения (tumaround time) - обеспечить минимальное время между стартом процесса или постановкой задания в очередь загрузки и его завершением.
﻿﻿- Сокращение времени ожидания (waiting time) - сократить время, проводимое в состоянии готовность.
﻿﻿- Сокращение времени отклика (response time) - минимизировать время ответа на запрос пользователя

Дополнительные требования к алгоритмам планирования:
﻿- ﻿Быть предсказуемыми. Одно и то же задание должно выполняться приблизительно за одно время.
﻿﻿- Иметь минимальные накладные расходы. Если на каждые 100 миллисекунд, выделенные процессу, 200 миллисекунд уходит на переключение контекста, то такой алгоритм, очевидно, применять не стоит.
﻿﻿- Равномерно загружать ресурсы вычислительной системы, отдавая предпочтение тем процессам, которые будут занимать малоиспользуемые ресурсы.
﻿﻿- Обладать масштабируемостью, т. е. не сразу терять работоспособность при увеличении нагрузки


### Параметры планирования
Все параметры планирования можно разбить на две большие группы: статически (неизменяемые в ходе выполнения) и динамические (изменяемые параметры).

К статическим параметрам ВС относят предельные значения ее ресурсов (размер ОП, емкость диска, размер области для свопинга, количество подключенных устройств ввода-сывода и т. п), а также
﻿- ﻿Каким пользователем запущен процесс или сформировано задание.
﻿﻿- Насколько важной является задача, каков ее приоритет
﻿﻿- Сколько процессорного времени запрошено для решения задачи
﻿﻿- Каково соотношение процессорного времени и времени для операций ввода-вывода
﻿﻿- Какие ресурсы ВС и в каком количестве необходимы зданию.

Динамические параметры системы описывают количество свободных ресурсов на данный момент, а также:
- Сколько времени прошло с момента выгрузки процесса на диск или его загрузки в ОП.
- Объем ОП, занимаемый процессом в текущий момент.
- Промежуток времени непрерывного использования процессора - **CPU burst**
- Промежуток времени непрерывного ожидания ввода-вывода - I/O burst


### Вытесняющее и невытесняющее планирование

Процесс планирования осуществляется частью ОС, называемой **планировщиком**, который принимает решения о выборе для исполнения нового процесса из числа находящихся в состоянии готовность в следующих четырех случаях:
﻿﻿﻿1. Процесс переводится из состояния исполнение в закончил исполнение.
﻿﻿﻿2. Процесс переводится из состояния исполнение в ожидание
﻿﻿﻿3. Процесс переводится из состояния исполнение в готовность (например, после прерывания от таймера).
﻿﻿﻿4. Когда процесс переводится из состояния ожидание в готовность (например, завершилась операция ввода-вывода или произошло другое событие).
В случаях 1 и 2 процесс, находившийся в состоянии исполнение, не может дальше исполняться, и ОС
вынуждена осуществлять планирование, выбирая новый. В случаях з и ц планирование может как проводиться, так и не проводиться

Если в ОС планирование осуществляется только в вынужденных ситуациях, то имеет место **невытесняющее** (nonpreemptive) планирование. Если принимаются и невынужденные решения, то говорят о **вытесняющем** (preemptive) планировании.

! При невытесняющем планировании в случае зависания ВС из-за зацикливания программы
единственное решение - перезагрузка всей системы. В вытесняющем работа построена н переключении к другому процессу по истечении некоторого интервала времени - кванта.


### Алгоритмы планирования. FCFS

Простейший алгоритм планирования **FCFS - First-Come, First-Served** (первым пришел, первым обслужен). Другой вариант обозначения **FIFO** - First-In, First - Out.
- **Принцип работы**. Очередь.
- **Разновидности планирования.** Не вытесняющее.
- **Достоинство.** Легкость реализации.
- **Недостаток.** Время выполнения зависит от порядка процессов в очереди.
![[Pasted image 20251002135800.png]]
![[Pasted image 20251002142601.png]]
Вывод: Алгоритм малоэффективен, если в начале очереди стоят (длинные) трудоемкие процессы, то показатели ухудшаются многократно.

### Алгоритмы планирования. RR
Модификацией алгоритма FCF5 является алгоритм, получивший название **RR - Round Robin** (Round Robin- это вид детской карусели в США).
﻿﻿- Принцип работы. Зацикленная очередь.
﻿﻿- Разновидность планирования. Вытесняющее.
﻿﻿- Достоинство. Большая гибкость, чем FCF5.
﻿﻿- Недостаток. На производительность сильно влияет величина кванта времени.

Сделать расчёт среднего времени ожидания и времени выполнения для кванта = 4 и для кванта =1
При выполнении процесса возможны 2 варианта:
﻿- ﻿Остаток текущего CPU burst меньше или равен продолжительности кванта времени. Тогда процесс по своей воле освобождает процессор до истечения кванта времени, на исполнение поступает новый процесс из начала очереди, и таймер начинает отсчет кванта заново.
﻿﻿- Остаток текущего CPU burst процесса больше, чем квант времени. Тогда по истечении этого кванта процесс прерывается таймером и помещается в конец очереди процессов, готовых к исполнению, а процессор выделяется для использования процессу, находящемуся в ее начале.
![[Pasted image 20251002142617.png]]
Вывод: Алгоритм более эффективен, чем FCFS, при уменьшении кванта времени, показатели улучшаются, но возрастают накладные расходы на переключение контекста,  что может замедлить систему.

### Алгоритмы планирования. SJF
Алгоритм, при котором наикратчайшая работа (процесс, задание) выполняется первой, называется **SJF - Shortest Job First**.
- **Принцип работы.** Процесс с наименьшим CPU burst выполняются сначала.
- **Разновидности планирования.** Невытесняющее и вытесняющее.
- **Достоинство.** Сокращение времени ожидания коротких процессов в очереди, как следствие, повышение производительности системы.
- **Недостаток.** Сложность точного программирования CPU burst для очередного процесса.
![[Pasted image 20251002143854.png]]
